#' Aggregate data across groups of cells
#' 
#' Sum counts or average expression values for each feature across groups of cells,
#' while also aggregating values in the \code{\link{colData}} and other fields in a SummarizedExperiment.
#'
#' @param x A \linkS4class{SingleCellExperiment} or \linkS4class{SummarizedExperiment}
#' containing one or more matrices of expression values to be aggregated;
#' possibly along with \code{\link{colData}}, \code{\link{reducedDims}} and \code{\link{altExps}} elements.
#' @inheritParams sumCountsAcrossCells
#' @param ... Further arguments to be passed to \code{sumCountsAcrossCells}.
#' @param use.assay.type A character or integer vector specifying the assay(s) of \code{x} containing count matrices.
#' @param use.altexps Logical scalar indicating whether aggregation should be performed for alternative experiments. 
#' Alternatively, a character or integer vector specifying the alternative experiments to be aggregated.
#' @param use.dimred Logical scalar indicating whether aggregation should be performed for dimensionality reduction results.
#' Alternatively, a character or integer vector specifying the dimensionality reduction results to be aggregated.
#' @param coldata.merge A named list of functions specifying how each column metadata field should be aggregated.
#' Each function should be named according to the name of the column in \code{\link{colData}} to which it applies.
#' Alternatively, a single function can be supplied, see below for more details.
#' @param use_exprs_values,use_altexps,use_dimred,coldata_merge
#' Soft deprecated equivalents to the arguments described above.
#'
#' @return 
#' A SummarizedExperiment of the same class as \code{x} is returned,
#' containing summed/averaged matrices generated by \code{sumCountsAcrossCell} on all assays specified in \code{use_exprs_values}.
#' Column metadata and other available metadata (e.g., reduced dimensions) are also aggregated, see below.
#'
#' @details
#' This function sums the assay values in \code{x} using \code{sumCountsAcrossCells}
#' while also aggregating metadata across cells in a \dQuote{sensible} manner.
#' This makes it useful for obtaining an aggregated \linkS4class{SummarizedExperiment} during an analysis session;
#' in contrast, \code{sumCountsAcrossCells} is more lightweight and is better for use inside other functions.
#' 
#' Aggregation of the \code{\link{colData}} is controlled using functions in \code{coldata_merge}.
#' This can either be:
#' \itemize{
#' \item A function that takes a subset of entries for any given column metadata field and returns a single value.
#' This can be set to, e.g., \code{\link{sum}} or \code{\link{median}} for numeric covariates,
#' or a function that takes the most abundant level for categorical factors.
#' \item A named list of such functions, where each function is applied to the column metadata field after which it is named.
#' Any field that does not have an entry in \code{coldata_merge} is \dQuote{unspecified} and handled as described below.
#' A list element can also be set to \code{FALSE}, in which case no aggregation is performed for the corresponding field.
#' \item \code{NULL}, in which case all fields are considered to be unspecified.
#' \item \code{FALSE}, in which case no aggregation of column metadata is performed.
#' }
#' For any unspecified field, we check if all cells of a group have the same value.
#' If so, that value is reported, otherwise a \code{NA} is reported for the offending group.
#'
#' If \code{x} is a \linkS4class{SingleCellExperiment},
#' the assay values in the \code{\link{altExps}} are subjected to a similar summation/averaging across cells.
#' This uses the same arguments that were used for the main experiment.
#' Values in the \code{\link{reducedDims}} are also averaged across cells (regardless of the value of \code{average}).
#'
#' Users can tune the behavior of the function for these additional fields with \code{use_altexps} and \code{use_dimred}.
#' Note that if the alternative experiments themselves are \linkS4class{SingleCellExperiment}s,
#' any further nested alternative experiment or reduced dimensions will always be aggregated
#' regardless of the value of \code{use_altexps} or \code{use_dimred}.
#' 
#' If \code{ids} is a DataFrame, the combination of levels corresponding to each column is also reported in the column metadata.
#' Otherwise, the level corresponding to each column is captured in the column names.
#'
#' @author Aaron Lun
#' @name aggregateAcrossCells
#'
#' @seealso
#' \code{\link{sumCountsAcrossCells}}, which does the heavy lifting.
#'
#' @examples
#' example_sce <- mockSCE()
#' ids <- sample(LETTERS[1:5], ncol(example_sce), replace=TRUE)
#' out <- aggregateAcrossCells(example_sce, ids)
#' out
#'
#' batches <- sample(1:3, ncol(example_sce), replace=TRUE)
#' out2 <- aggregateAcrossCells(example_sce, 
#'       DataFrame(label=ids, batch=batches))
#' out2
#'
#' # Using another column metadata merge strategy.
#' example_sce$stuff <- runif(ncol(example_sce))
#' out3 <- aggregateAcrossCells(example_sce, ids, 
#'      coldata_merge=list(stuff=sum))
#' out3
NULL

#' @export
#' @rdname aggregateAcrossCells
setGeneric("aggregateAcrossCells", function(x, ...) standardGeneric("aggregateAcrossCells"))

#' @export
#' @rdname aggregateAcrossCells 
#' @importFrom S4Vectors DataFrame
#' @importFrom SummarizedExperiment assay assays<- colData<- colData assayNames
setMethod("aggregateAcrossCells", "SummarizedExperiment", function(x, ids, ..., 
    subset.row=NULL, subset.col=NULL, store.number="ncells", coldata.merge=NULL, use.assay.type="counts",
    subset_row=NULL, subset_col=NULL, store_number="ncells", coldata_merge=NULL, use_exprs_values=NULL)
{
    subset.row <- .replace(subset.row, subset_row)
    subset.col <- .replace(subset.col, subset_col)
    store.number <- .replace(store.number, store_number)
    coldata.merge <- .replace(coldata.merge, coldata_merge)
    use.assay.type <- .replace(use.assay.type, use_exprs_values)

    new.ids <- .process_ids(x, ids, subset.col)
    new.ids.char <- as.character(new.ids) # Avoid re-coercion on every call to the output function.

    use.assay.type <- .use_names_to_integer_indices(use.assay.type, x=x, nameFUN=assayNames, msg="use.assay.type")
    if (length(use.assay.type)==0L) {
        stop("'use.assay.type' must specify at least one assay")
    }

    collected <- list()
    ncells <- NULL
    for (i in seq_along(use.assay.type)) {
        sum.out <- .sum_across_cells(assay(x, use.assay.type[i]), 
            ids=new.ids, ..., subset.row=subset.row)
        ncells <- sum.out$freq
        collected[[i]] <- sum.out$mat
    }
    names(collected) <- assayNames(x)[use.assay.type]

    cn <- colnames(collected[[1]])
    m <- match(cn, new.ids.char)
    coldata <- .create_coldata(ids, mapping=m, freq=ncells, store.number=store.number)

    # Ensure endomorphism by modifying the original object.
    shell <- x[,m]
    if (!is.null(subset.row)) {
        shell <- shell[subset.row,]
    }
    assays(shell, withDimnames=FALSE) <- collected
    new.cd <- .merge_DF_rows(colData(x), ids=new.ids.char, final=cn, mergeFUN=coldata.merge)

    # Need row.names here to guarantee the correct number of rows when new.cd
    # is empty; even if we remove the row names later.
    new.cd <- do.call(DataFrame, c(new.cd, list(row.names=cn))) 
    colData(shell) <- cbind(new.cd, coldata)

    if (.has_multi_ids(ids)) {
        colnames(shell) <- NULL
    }
    shell
})

.use_names_to_integer_indices <- function(use, x, nameFUN, msg) {
    if (isTRUE(use)) {
        use <- seq_along(nameFUN(x))
    } else if (isFALSE(use)) {
        use <- integer(0)
    } else if (is.character(use)) {
        use <- match(use, nameFUN(x))
        if (any(is.na(use))) {
            stop(sprintf("'%s' contains invalid values", msg))
        }
    } else {
        if (any(use < 1L) || any(use > length(nameFUN(x)))) {
            stop(sprintf("'%s' contains out-of-bounds indices", msg))
        }
    }
    use
}

#' @importFrom BiocGenerics match
#' @importFrom S4Vectors split 
.merge_DF_rows <- function(x, ids, final, mapping=match(final, ids), mergeFUN=NULL) {
    collected <- list()
    if (isFALSE(mergeFUN)) {
        return(collected)
    }

    for (cn in colnames(x)) {
        if (!is.function(mergeFUN)) {
            FUN <- mergeFUN[[cn]]
            if (isFALSE(FUN)) {
                collected[[cn]] <- NULL
                next
            }
        } else {
            FUN <- mergeFUN
        }

        grouped <- split(x[[cn]], ids)[final]

        if (is.null(FUN)) {
            # Obtaining a NA of matched type.
            FUN <- function(x) {
                if (length(val <- unique(x))==1L) {
                    val 
                } else {
                    val[1][NA]
                }
            }
        }

        per.group <- lapply(grouped, FUN)
        per.group <- unname(per.group)
        if (length(per.group)>=1L) {
            # Using 'c' instead of unlist to accommodate Vectors.
            collected[[cn]] <- do.call(c, per.group)
        } else {
            # Obtaining a column of the correct type.
            collected[[cn]] <- FUN(x[[cn]])[0]
        }
    }

    collected
}

#' @export
#' @rdname aggregateAcrossCells 
#' @importFrom SingleCellExperiment altExp altExps altExp<- altExps<-
#' reducedDimNames reducedDim<- reducedDim reducedDims<- reducedDims
setMethod("aggregateAcrossCells", "SingleCellExperiment", function(x, ids, ..., 
    subset.row=NULL, subset.col=NULL, store.number="ncells", coldata.merge=NULL, 
    use.assay.type="counts", use.altexps=TRUE, use.dimred=TRUE,
    subset_row=NULL, subset_col=NULL, store_number="ncells", coldata_merge=NULL, 
    use_exprs_values=NULL, use_altexps=NULL, use_dimred=NULL)
{
    subset.row <- .replace(subset.row, subset_row)
    subset.col <- .replace(subset.col, subset_col)
    store.number <- .replace(store.number, store_number)
    coldata.merge <- .replace(coldata.merge, coldata_merge)
    use.assay.type <- .replace(use.assay.type, use_exprs_values)
    use.altexps <- .replace(use.altexps, use_altexps)
    use.dimred <- .replace(use.dimred, use_dimred)
   
    base.args <- list(x=x, ids=ids, ..., subset.col=subset.col, 
        coldata.merge=coldata.merge, store.number=store.number, 
        use.assay.type=use.assay.type)

    y <- do.call(callNextMethod, c(base.args, list(subset.row=subset.row)))

    use.altexps <- .use_names_to_integer_indices(use.altexps, x=x, nameFUN=altExpNames, msg="use.altexps")
    for (i in use.altexps) {
        # Do NOT pass use.altexps and use.dimred, as this
        # part must work with any SE object.
        args <- base.args
        args$x <- altExp(x, i)
        altExp(y, i) <- do.call(aggregateAcrossCells, args)
    }
    altExps(y) <- altExps(y, withColData=FALSE)[use.altexps]

    new.ids <- .process_ids(x, ids, subset.col)
    use.dimred <- .use_names_to_integer_indices(use.dimred, x=x, nameFUN=reducedDimNames, msg="use.dimred")
    for (i in use.dimred) {
        # We re-use sumCountsAcrossCells rather than using something
        # else like rowsum(), in order to ensure that the order of the
        # _rows_ here is the same as that in the aggregated `y`.
        current <- t(reducedDim(x, i))
        out <- .sum_across_cells(current, ids=new.ids, average=TRUE)
        reducedDim(y, i) <- t(out$mat)
    }
    reducedDims(y) <- reducedDims(y, withDimnames=FALSE)[use.dimred]

    y
})
